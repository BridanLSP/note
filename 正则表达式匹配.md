# 正则表达式匹配
s : _aab
p : _c*a*b

aa
a*

dp[i][j] 表示 s[0 : i] 和 p[0 : j] 匹配。最后dp[n][m] = true，表示s和p匹配。

## 状态转移
1. p[j]是普通字符。因为s[i]也是普通字符，如果p[0 : i]与p[0 : j]匹配，则只需判断s[i] == s[j]。
2. p[j]是星号。则需要看p[j-1]。dp[1][1] = true  dp[1][2]
	* s = "da", p = "dac*",
	匹配0个p[j-1]，可得f(i,j) = f(i, j - 2)
	* s = "dac", p = "dac*" dp[2][2] = true dp[2][3]
	匹配1个p[j-1], 
	f(i,j) = f(i - 1, j - 2) && (s[i] == p[j - 1] || p[j - 1] == '.')
	* s = "dacc", p = "dac*" dp[2][2] = true  dp[3][3] = ?
	匹配2个p[j-1], 
	f(i,j) = f(i - 2, j - 2) && ((s[i] == p[j - 1] && s[i - 1] == p[j - 1]) || p[j - 1] == '.')

s[i-1] = [j-1] && s[i] = p[j-1]

f(i-1, j) = f(i-1, j-2) || (f(i-2, j-2) && s[i-1] == p[j-1])

s[i] == p[j-1] && f(i-1, j) = (f(i-1, j-2) && s[i] == p[j-1])  || (f(i-2, j-2) && s[i-1] == p[j-1] && s[i] == p[j-1])