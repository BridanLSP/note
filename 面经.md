# 校招go面经

## 1. go里面线程，进程，协程的区别
进程是指在操作系统中运行的程序，进程是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间和资源，包括栈、寄存器、虚拟内存、文件句柄等。所以进程上下文切换开销比较大，但相对稳定安全。

线程是进程的一个实体，是CPU分配和调度的基本单位。他是比进程更小并能独立运行的单位，线程上本身不占有系统资源，只拥有运行中必不可少的资源，比如程序计数器，一组寄存器和栈。但他可以和同属一个进程的其他线程共享进程所拥有的全部资源。线程间通信主要通过共享内存完成，上下文切换很快，资源开销较少，但相对进程而言不够稳定，容易丢失数据。

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程有自己的寄存器和栈。协程调度切换时，将硬件上下文和栈保存在用户栈/堆中，只需要在用户态内完成。线程切换需要借助内核完成，需要从用户态切换到内核态，然后再从内核态切回用户态。所以线程上下文切换更快。

一个进程可以包含多个线程，一个线程可以包含多个协程。虽然一个线程内的多个协程可以切换但是这多个协程是串行执行的，某个时刻只能有一个协程在运行，没法利用CPU的多核能力。和coroutine不同的是，goroutine可以并发执行。
协程的运行机制属于协作式任务处理，通过让出和重启操作写作。应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。

### 进程切换为什么比线程切换慢
https://leetcode.cn/circle/discuss/G1XhdU/
就是说，每个进程都拥有一个自己的虚拟地址空间，并且独立于其他进程的地址空间，然后每个进程包含的栈、堆、代码段这些都会从这个地址空间中被分配一个地址，这个地址就被称为虚拟地址。底层指令写入的地址也是虚拟地址。

有了虚拟地址空间后，CPU 就可以通过虚拟地址转换成物理地址这样一个过程，来间接访问物理内存了。

地址转换需要两个东西，一个是 CPU 上的内存管理单元 MMU，另一个是内存中的页表，页表中存虚拟地址到物理地址的映射

但是呢，每次访问内存，都需要进行虚拟地址到物理地址的转换，这样的话，页表就会被频繁地访问，而页表又是存在于内存中的。所以说，访问页表（内存）次数太多导致其成为了操作系统地一个性能瓶颈。

于是，引入了转换检测缓冲区 TLB，也就是快表，其实就是一个缓存，把经常访问到的内存地址映射存在 TLB 中，因为 TLB 是在 CPU 的 MMU 中的嘛，所以访问起来非常快。



然后，正是因为 TLB 这个东西，导致了进程切换比线程切换慢。

由于进程切换会涉及到虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢。


## 2. 完全二叉树与搜索二叉树的概念
完全二叉树：一颗二叉树，从根开始添加结点，从上到下，从左到右地添加，最后得到的就是完全二叉树。
如何验证： 层序遍历，如果一个结点左孩子为空而右孩子不为空，则该树一定不是完全二叉树。如果一个结点的左孩子不为空且右结点为空或为该结点为叶子结点，则队列中该结点之后的结点都应该为叶子结点。
搜索二叉树：对于树中任何一个非空结点，它左子树中任何一个结点都小于它，它右子树中任何一个结点都大于它。
满二叉树：每层的结点都达到最大值。
## 3. go垃圾回收机制
Go的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。

1. 栈扫描（开始时stw）
2. 第一次标记（并发）
3. 第二次标记（stw）
4. 清除（并发）

go的垃圾回收采用三色标记法

三色不变性：
白色对象：未被回收器访问到的对象。
灰色对象：已经被回收器访问到的对象，还需要对其中的一个或多个指针扫描。
黑色对象：已被回收器访问到的对象，所有指针都被扫描，黑色对象任何一个指针都不可能直接指向白色对象。

四个阶段：
整个进程空间中，每个对象占据的内存可以看成一个图，初始状态下每个内存对象都是白色标记。
1. 先stw，做一些准备工作比如开启写屏障。然后取消stw，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理。
2. 第一阶段，先扫描root对象，包括全局指针和goroutine栈上的指针，标记为灰色放入队列。
3. 第二阶段，将第一轮队列中的对象所引用的对象置为黑色并加入队列。直到这个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即为不可到达的、未被引用的对象。
4. 第三阶段，再次stw,将写屏障记录的所有修改的指针也加入队列并进行扫描。
5. 第四阶段，内存中只存在白色对象和黑色对象，清除所有白色对象。

go的设计目标是让gc和用户代码更好地并发执行（就是减少stw的时间）。

### 为什么使用写屏障？
因为go支持并行GC, GC的扫描和go代码可以同时运行, 这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树。

例如开始扫描时发现根对象A和B, B拥有C的指针。

GC先扫描A，A放入黑色
B把C的指针交给A
GC再扫描B，B放入黑色
C在白色，会回收；但是A其实引用了C。
为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier).
启用了写屏障(Write Barrier)后，在GC第三轮rescan阶段，根据写屏障标记将C放入灰色，防止C丢失。

垃圾回收器的正确性体现在：不应该出现对象的丢失，不应该回收不需要回收的对象。当以下两个条件同时满足时会破坏垃圾回收器的正确性：
1. 赋值器修改对象图，导致某一黑色对象引用白色对象。
2. 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。

如果条件1被避免而出现条件2时，假设用户代码执行中，灰色对象不在需要某个白色对象，于是破坏了他们之间未经访问的路径，最终导致该白色对象被回收。但是黑色对象无法引用白色对象，所以，没有对象会丢失。

如果条件2被避免而出现条件1时，黑色对象引用了一个白色对象。但不允许用户代码在这段时间内破坏路径，只要存在未访问的能够到达白色对象的路径，就可以将黑色对象指向白色对象。

于是允许条件1，避免条件2，引入弱三色不变性。当强弱三色不变性不被打破时，回收器正确性就不会被打破，

赋值器的写屏障作为一种同步机制，使赋值器在进行指针写操作时，能够“通知”回收器，进而不会破坏弱三色不变性。

## 4. b树和b+树的区别
b树是一种多路自平衡的搜索树。

1. 所有键值分布在整颗树中（索引值和具体data都在每个结点里。
2. 任何一个关键字出现且只出现在一个结点中。
3. 搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据。
4. 在关键字全集里做一次查找，性能接近二分查找。

b树是专门为外部存储器设计的，比如磁盘。他对于读取和写入大块的数据有良好的性能，一般用于文件系统和数据库中。子节点数量一般上千，具体数目依赖外部存储器特性。

平衡二叉树比如AVL树和红黑树，这些树在一般情况查询性能非常好，但是当数据非常大的时候就无能为力了。因为数据量大，内存不够用，大部分数据只能存放于磁盘，只能把需要的加载到内存。因为访问内存速度和读取磁盘速度差了5个数量级，所以磁盘读取时间远远超过了数据在内存比较的时间，影响性能的关键结点就变成了磁盘IO了。

平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。其次平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理），所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了。

空间局部性原理：如果一个存储器的某个位置被访问，那么它附近的位置也会被访问。

B+树是B树的变体，也是一种多路搜索树, 它与 B树的不同之处在于:
1. 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)
2. 为所有叶子结点增加了一个链指针

b树和b+树的不同：
1. 由于B+树所有的 data 域都在叶子节点，所以查询 key 为 50的节点必须从根节点索引到叶节点，时间复杂度固定为 O(log n)。
2. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

B+树可以很好的利用局部性原理，若我们访问节点 key为 50，则 key 为 55、60、62 的节点将来也可能被访问，我们可以利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。

当然B+树也能够很好的完成范围查询。比如查询 key 值在 50-70 之间的节点。由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快。
3. .B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确。那么由于磁盘 IO 数据大小是固定的（一页），在一次 IO 中，单个元素越小，量就越大。这就意味着B+树单次磁盘 IO 的信息量大于B-树，从这点来看B+树相对B-树磁盘 IO 次数少。
   
## 5. 五层协议
应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等/协议。数据单位为报文。

传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

网络层
OSI模型：第三层、TCP/IP模型：第二层
关键协议：IP协议、ICMP协议（差错报告）

网络层属于主机之间的通信，它的目的是向上提供简单灵活的、无连接的、尽最大努力交付的数据报服务，网络层不提供服务质量的承诺。

特点：不需要建立连接、每个数据报单独路由、每个数据报有完整的目标地址（指IP地址）、不提供可靠的连接、到达终点可能无序、由终点进行差错控制

传输层
OSI模型：第四层、TCP/IP模型：第三层
关键协议：TCP协议、UDP协议

传输层属于主机间不同进程的通信，传输层向上面的应用层提供通信服务，并屏蔽了下面的核心网络细节，使得面向传输层编程就像是两个主机进程之间有一条端到端的逻辑信道一样；当传输层采用TCP协议时，这条逻辑通信信道就是一条可靠的通信信道，而尽管下面的网络是不可靠的。

应用层
关键协议：HTTP协议、FTP协议、SMTP协议、DNS等等
定义了运行在不同端系统上的应用程序进程如何相互传递报文

网络层：提供了主机之间的通信
传输层：提供主机不同进程之间的通信
应用层：提供不同应用之间的通信
实际上，应用层定义了进程交换的报文类型、报文的语法、字段的含义、进程如何发生数据、怎么样发送数据等等。

## 6. TCP/IP
它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。
![图](https://pic.leetcode-cn.com/1646808866-dgfZpj-image.png)

## 7. UDP和TCP的区别
传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务，上层协议号。

## 8. 从应用层到网络层各层的header都有什么不同的功能
* 链路层：含有前同步码，让接收端和发送端频率相同。帧开始定界符，告诉接收端适配器接受数据。目的地址和源地址，这里都是网络适配器的MAC地址，上层协议号。
* 网络层：版本、服务类型、首部长度、首部校验和，源IP地址，目的IP地址，寿命（防止加入路由循环）、上层协议号（6交给tcp，17交给udp）。
* 传输层：udp，源端口号，目的端口号。校验和。tcp源端口号、目的端口号，序列号、确认号、状态码和接收窗口大小。
* 应用层：功能根据应用层协议的需求定制，比如http有响应码。
  
## 9. 堆排序
64匹马，8条赛道，问最少几次赛跑可以找到最快的4匹马？

12。9次出最快。然后最快第一次比赛中排名第二的马a跟决赛其他七匹比出第二快的。如果a是这一组中最快的，那么就把最快第一次比赛中第三的马b跟决赛其他七匹马比。如果是决赛七匹马中的p是这一组中最快的，就找到a和p第一次比赛中排名第二的马q和决赛其他六匹马比。得到最快之后，每找一匹马，只需要一场。

## 10. cpu的调度算法

## 11. 进程上下文包括
进程上下文包括三个，用户级上下文，寄存器上下文和系统级上下文
用户级上下文：指令，数据，共享内存、用户栈
寄存器上下文：程序计数器，通用寄存器，控制寄存器，状态字寄存器，栈指针（用来指向用户栈或者内存栈）
系统级上下文：pcb，主存管理信息（页表&段表）、核心栈

## 12. linux内存空间分布
高地址为内核空间，低地址为用户空间。
用户空间下，程序又分为六个部分。
1. 代码段，通常只读，运行前已经确定。
2. 常量段，存储常量，只读。
3. 数据段，存储已经初始化的全局变量，属于静态内存分配。
4. bss段。存储没有被初始化的全局变量，属于静态内存分配。
5. stack段。存储参数变量和局部变量，由系统申请和释放。静态，可以用于保存现场。
6. heap段，程序在运行中被动态分配的内存段，由用户申请和释放。

## 13. OSI七层网络
1. 物理层：定义了用于激活、维护和停用网络设备之间的物理连接的电气、机械、程序和功能规范。
2. 数据链路层：数据链路层允许局域网内的各节点彼此相互通信。这一层建立了线路规划、流量控制和错误控制的基础。（MAC）
3. 网络层：IP协议，使路由器可以跨越多个网络传输数据包。路由器连接到ISP，还记载所在网络中所有设备mac地址以及IP。
4. 传输层：传输层通过将消息分割成多个数据包提供端到端的消息传输，支持面向连接的和无连接的通信。
5. 会话层: 会话层负责初始化、维持并终止两个用户应用程序之间的连接。它响应来自表示层的请求，并向传输层发起请求。
6. 表示层：负责数据的格式，比如字符编码与转换，以及数据加密。
7. 应用层：这一层最终负责支持用户程序使用的服务。
## 14. 数据库acid
https://cloud.tencent.com/developer/article/1888427

## 15. go
https://blog.csdn.net/qq_43716830/article/details/124405506?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166324091516782395359972%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166324091516782395359972&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-124405506-null-null.142^v47^new_blog_pos_by_title,201^v3^control_1&utm_term=go%20%E5%85%AB%E8%82%A1%E6%96%87&spm=1018.2226.3001.4187