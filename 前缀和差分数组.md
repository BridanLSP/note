# 前缀和差分数组
源自[出行计划](http://118.190.20.162/view.page?gpid=T142)


## 前缀和
假设有一个数组`a = [0, 1, 2, 3, 4, 5]`，题目会输入`(l,r)`,求数组`a[l]`到`a[r]`之和。如果查询的次数很多，可以使用前缀和预处理数组，减少计算量。求前缀和的方法是：
``` python
for i in range(1, len(a)):
    p[i] = a[i] + a[i-1]
```
得到数组`p = [0, 1, 3, 6, 10, 15]`，当题目输入`(1, 4)`时，可以很快地通过`p[r] - p[l-1] = p[4] - p[0] = 10`得到答案而不用去累加求和。

## 差分数组
假设有一个数组`a = [2, 4, 3, 5, 7, 6]`,求差分数组的方法是：
``` python
for i in range(1, len(a)):
    d[i] = a[i] - a[i-1]
```
它的差分数组是`d = [2, 2, -1, 2, 2, -1]`。当需要多次对数组的某一片段加同一个数或者减去同一个数时，使用差分数组做预处理可以减少计算量。假如从`a[l]`到`a[r]`都减去`5`，那么只需要`d[l]-5, d[r+1]-(-5)`,用两端的计算代替一个切片中每个元素的计算。因为在切片中`a[l]`和`a[i+1]`都减去了`5`，所以，他们在差分数组的值` d[i] = a[i] - a[i-1]`仍然保持不变。当`l = 1, r = 4`:
``` python
d[1] - 5 = -3
d[5] - (-5) = 4
a = [2, -1, -2, 0, 2, 1]  # 从a[1]到a[4]都-5
d = [2, -3, -1, 2, 2, 4]  # -5后的差分数组

a = [2, -1, -2, 0, 2, 6]  # 从差分数组还原的数组
```
当差分数组经过更改后，我们仍然可以根据`a[i] = d[i] + a[i-1]`求`a[1], a[2], ..., a[n]`，逐步向后还原数组。

## 代码和题解
从题目可得知，满足`q+k <= t <= q+k+ci-1`才能进入。因为`q`可能是大量查询的变量，所以可以把不等式化为`t-k-ci+1 <= q <= t-k`，令等式两边为常量。假设我们有n个出行计划，如果只是对等式两边做预处理，节省每次计算时间，需要比较`n`次。然后输入`m`条查询，则需要`n*m`次运算。如果对于每个出行计划，都记录满足要求的`q`,每次输入`q`都从数组中返回那个时间能满足的出行计划个数，则只需要耗时`n+m`次。

``` python
n, m, k = map(int, input().split())
#ci <= 200000, 数目以内的q都可能生效
#一开始都是0，所以差分数组初始化为0，留一个d[200001],如果右区间到了d[200000],
#代码里会修改d[200001]
d = [0]*200001  
for i in range(n):
    t,c = map(int, input().split())
    # 给区间内的q+=1 => 给区间两端做处理
    d[max(1, t-k-c+1)] += 1  # q >= 1，最左端为1
    d[max(1, t-k+1)] -= 1    # 区间右端后一位 -= 1
for i in range(1, 200001):
    d[i] += d[i-1]           # 把差分数组还原，d[q]代表q时做核酸满足的出行计划个数
for i in range(m):
    q = int(input())
    print(d[q])
```